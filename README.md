# Сollection of custom orders
## 1. Мета проєкту
Створення веб-застосунку для перевірки можливості конфігурації технічних
продуктів з використанням алгоритму 2-SAT (2-Satisfiability). Додаток дозволяє
користувачам вибирати компоненти та автоматично перевіряти їх сумісність на
основі заданих правил (вимог та конфліктів).
## 2 Основні функції
# 2.1. Основні можливості:
Вибір типів продуктів з готовими шаблонами
Завантаження власних конфігурацій через файли
Візуальний вибір компонентів з описом
Два алгоритми перевірки: базова перевірка та 2-SAT
Автоматичне виявлення конфліктів та невідповідностей
Відображення всіх можливих конфігурацій
Експорт/імпорт конфігурацій
# 2.2. Підтримувані типи продуктів:
1. Кавовий апарат (6 компонентів)
2. Пилосос (5 компонентів)
3. Фехтувальне спорядження (11 компонентів)
4. Кастомні продукти (з завантаження файлів)
## 3. Реалізовані алгоритми
# 3.1. Алгоритм 2-SAT
Принцип роботи:
# 1. Кодування правил:
Кожна компонента → булева змінна
A REQUIRES B → (¬A ∨ B) (A → B)
A CONFLICTS B → (¬A ∨ ¬B) (A → ¬B ∧ B → ¬A)
# 2. Побудова графу імплікацій:
Вершини: змінні та їх заперечення
Ребра: імплікації між вершинами
# 3. Алгоритм Тар'яна:
Знаходження компонент сильної зв'язності (SCC)
Перевірка суперечностей (x та ¬x в одній SCC)
# 4. Призначення значень:
Топологічне сортування компонент
Послідовне призначення True/False
Асимптотична складність:
• Побудова графу: O(N + M), де N - компоненти, M - правила
• Алгоритм Тар'яна: O(N + M)
• Загальна складність: O(N + M)
3.2. Базова перевірка
Простий алгоритм, який перевіряє:
1. Наявність всіх необхідних компонентів (REQUIRES)
2. Відсутність конфліктуючих компонентів (CONFLICTS)
Складність: O(R + C), де R - вимоги, C - конфлікти
## 4. Архітектура проєкту:
# 4.1. Структура модулів:
Input_txt.txt
sat_solver.py # Алгоритм 2-SAT та допоміжні функції
man_function.py # Веб-інтерфейс Streamlit
## 4.2. Основні класи/функції:
# sat_solver.py:
• solve_2sat_from_rules() - головна функція алгоритму
• find_feasible_configurations() - пошук всіх можливих конфігурацій
• read_config_from_file() - парсинг файлів конфігурації
• cnf_inputs() - конвертація правил у CNF форму
• build_graph_from_cnf() - побудова графу імплікацій
• tarjan_scc() - алгоритм Тар'яна для SCC
# man_function.py :
• Інтерактивний веб-інтерфейс
• Управління станом сесії
• Візуалізація результатів
## 5. Особливості реалізації
# 5.1. Робота з файлами:
Формат файлу конфігурації:
Рапіра CONFLICTS Шпага
Рапіра CONFLICTS Шабля
Шпага CONFLICTS Шабля
Рапіра REQUIRES Маска
Рапіра REQUIRES Куртка
Рапіра REQUIRES Штани
Рапіра REQUIRES Рукавиця
Рапіра REQUIRES Гетри
Шпага REQUIRES Маска
Шпага REQUIRES Куртка
Шпага REQUIRES Штани
Шпага REQUIRES Рукавиця
Шпага REQUIRES Гетри
Шабля REQUIRES Маска
Шабля REQUIRES Куртка
Шабля REQUIRES Штани
Шабля REQUIRES Рукавиця
Шабля REQUIRES Гетри
Рапіра REQUIRES Пані Юля та Пан Андрій поставте максимум
Рапіра REQUIRES ЖилетПроводка_Рапіра
Шпага CONFLICTS Пані Юля та Пан Андрій поставте максимум
Шпага CONFLICTS ЕлектроКуртка_Шабля
Шпага CONFLICTS ЖилетПроводка_Рапіра
Шабля REQUIRES ЕлектроКуртка_Шабля
Шабля CONFLICTS Пані Юля та Пан Андрій поставте максимум
Шабля CONFLICTS ЖилетПроводка_Рапіра5.2. Обробка великих наборів:
Для пошуку всіх можливих конфігурацій (find_feasible_configurations)
використовується перебір всіх комбінацій (2^N), що обмежує використання для
великих N (>20).
# 5.3. Оптимізації:
1. Кешування результатів 2-SAT для швидкої перевірки
2. Ефективна побудова графу через словники
3. Візуальні підказки для користувачів
6. Результати тестування
# 6.1. Тестові сценарії:
Кавовий апарат:
 РезервуарМолока + Тент + КаналПромивки → OK
 ТенМолока + КаналПромивки → OK
 ВеликийРезервуарВоди + ДодатковийТен → Conflict
 РезервуарМолока без Тента → Missing requirement
Фехтувальне спорядження:
 Рапіра з усім необхідним спорядженням → OK
 Рапіра + Шпага → Conflict
 Рапіра без Маски → Missing requirement
## 6.2. Порівняння алгоритмів:
Базова перевірка — це  легкий і економний спосіб. 
Вона займає мінімум пам’яті комп'ютера, але й можливості в неї скромні:
вона розбирається тільки в простих ситуаціях, часто пропускає складні зв'язки 
і не може показати всіх можливих варіантів розв'язку.
А от алгоритм 2-SAT проацює набагато ефективніше
Так, він вимагає більше пам’яті, але зате працює надійно. 
Він бачить повну картину, чудово справляється із заплутаними умовами і, що важливо,
здатен знайти абсолютно всі правильні варіанти, а не просто сказати «так» чи «ні».
## 7. Переваги та недоліки
# 7.1. Переваги:
1. Ефективність алгоритму 2-SAT (лінійна складність)
2. Масштабованість для великих наборів правил
3. Гнучкість у визначенні залежностей
4. Зручний інтерфейс з візуальними підказками
5. Підтримка кастомних конфігурацій
# 7.2. Недоліки:
1. Експоненційний пошук всіх можливих конфігурацій
2. Обмежена кількість шаблонів за замовчуванням
3. Відсутність збереження історії між сесіями
## Висновок:
Ми успішно реалізували алгоритм 2-SAT для перевірки конфігурацій, наш сайт
створений як і для розробників так і для клієнтів ( однак тут функція з файлами
вже не буде потрібна ), була створена візуалізація, крім того завдяки алгоритму
ми не тільки перевіряємо а ще пропонуємо можливі конфігурації ( та каже що
видалити у разі помилки )
# Загалом:
Проєкт демонструє ефективне застосування алгоритмічної теорії (2-SAT) для
розв'язання практичної задачі перевірки сумісності компонентів. Алгоритм
дозволяє обробляти складні логічні залежності між компонентами з лінійною
складністю, що робить його придатним для роботи з великими наборами
правил( однак в цьому випадку, можливі комбінації будуть відсутні )
## Хто що робив:
# Катерина Руденко :
Створення модулю для створення вхідних данних, реалізація функцій з
кастомними файлами, які створює користувач, брала участь у створенні
презентації
# Антоніна Якубовська:
Перетворювала конфігурації у кнф двома різними методами ( зчитування файлу
та прийняття списків), перетворюючи на вихід словник, також брала участь у
створенні презентації
# Настя Шопська:
Реалізація алгоритма Тар’ян і пошуку розв’язку 2-SAT задачі через SCC
алгоритм, також написала програму для знаходження можливих конфігурацій і
main
# Михайло Степанюк та Владислав Ткачук:
Створення гарного візуалу у вигляді сайту 
